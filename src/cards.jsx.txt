 DO NOT USE THIS FILE. IT IS ONLY FOR REFERENCE.

// Required Dependencies:
// npm install jquery
// npm install --save-dev @types/jquery

// === cards.ts ===
/*jslint vars: true, plusplus: true, -W003 */
/*jshint esversion: 6 */
/*globals window, document, define, exports, module, require */
import $ from 'jquery';

// Type Definitions
interface CardsOptions {
    spacing: number;
    radius: number;
    flow: 'horizontal' | 'vertical';
    fanDirection: 'N' | 'S' | 'E' | 'W';
    imagesUrl: string;
    width?: number;
    cards?: string[] | string; // Can be array or space-separated string
    generator?: string; // e.g., 'random'
}

interface CardCoord {
    x: number;
    y: number;
    angle: number;
}

interface Box {
    width: number;
    height: number;
}

// Define the structure for the parsed options from data attributes
// It's a partial set of CardsOptions, but values might be strings initially
type ParsedOptions = Partial<Omit<CardsOptions, 'cards'>> & {
    cards?: string | string[]; // Keep cards flexible here
    [key: string]: string | number | string[] | undefined; // Allow other string keys
};


// Attempt to get the current script to determine the path
// Note: document.currentScript might be null in some scenarios (e.g., modules, async loading)
let cardsScript: HTMLScriptElement | null = document.currentScript as HTMLScriptElement | null;

// Placeholder for the missing generateSingleHand function
// In a real scenario, this should be replaced with the actual implementation
function generateSingleHand(): string[] {
    console.warn("generateSingleHand() is not implemented. Returning default hand.");
    // Example implementation: returns a fixed hand
    const suits = ['S', 'H', 'D', 'C'];
    const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K'];
    const deck = suits.flatMap(suit => ranks.map(rank => rank + suit));
    // Shuffle (simple Fisher-Yates)
    for (let i = deck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
    }
    return deck.slice(0, 5); // Return 5 cards
}


// UMD Pattern Implementation (adapted for TypeScript module export)
// The original UMD wrapper tries to detect AMD, CommonJS, and browser globals.
// In TypeScript, we typically export the module directly and rely on the build
// system (like tsc, webpack, rollup) to create the desired bundle format (UMD, CJS, ESM).
// This code exports the module directly.

const cardsModule = (function ($: JQueryStatic) {
    'use strict';

    // Define the module object with explicit typing
    const module: {
        options: CardsOptions;
        cid: (card: JQuery<HTMLImageElement>) => string;
        play: (card: JQuery<HTMLImageElement>) => void;
        remove: (card: JQuery<HTMLImageElement>) => void;
        fan: (hand: JQuery<HTMLElement>, cfg?: Partial<CardsOptions>) => void;
        hand: ($hand: JQuery<HTMLElement>, cfg?: Partial<CardsOptions>) => void;
        cardSetTop: (card: HTMLImageElement, top: number) => void;
        cardNames: (cards: string | string[]) => string[];
        playCard: (card: JQuery<HTMLImageElement>) => void; // Initially points to remove
    } = {
        options: {
            spacing: 0.20,  // How much to show between cards, expressed as percentage of textureWidth
            radius: 400,    // This is the radius of the circle under the fan of cards and thus controls the overall curvature of the fan. Small values means higher curvature
            flow: 'horizontal', // The layout direction (horizontal or vertical)
            fanDirection: "N",
            imagesUrl: 'cards/' // The base URL for the card images, should end with a '/'.
        },

        // Gets the ID of the card, e.g. "KS" for the king of spades.
        cid: function (card: JQuery<HTMLImageElement>): string {
            let s = card.attr('src') || ''; // Ensure s is a string, even if src is missing
            // Use slice instead of substring for potentially cleaner negative index handling (though not used here)
            // return s.substring(s.length - 6, s.length - 4);
            return s.slice(-6, -4); // Extracts the two characters before '.svg'
        },

        // Play is called whenever a card in an hand is clicked.  If the hand is active
        // then playCard is called.
        play: function (card: JQuery<HTMLImageElement>): void {
            // Use closest() for potentially better performance and clarity
            if (card.closest(".active-hand").length > 0) {
                this.playCard(card);
            }
        },

        // Remove a card from the hand.
        remove: function (card: JQuery<HTMLImageElement>): void {
            let hand = card.parent();
            card.remove();

            // New layout if card removed from a "fan".
            if (hand.hasClass("fan")) {
                // Re-apply fan layout to the remaining cards
                this.fan(hand as JQuery<HTMLElement>); // Cast needed as parent() returns JQuery<HTMLElement>
            }
            // Note: The original code didn't re-layout non-fan hands after removal.
            // This behavior is preserved.
        },

        fan: function (hand: JQuery<HTMLElement>, cfg?: Partial<CardsOptions>): void {
            // Create a mutable copy of default options
            let options: CardsOptions = { ...this.options };
            let cards: JQuery<HTMLImageElement>;

            // Extend options with data attributes, then with cfg
            options = $.extend(options, readOptions(hand, 'fan'));
            if (cfg) {
                options = $.extend(options, cfg);
            }
            // Store the effective options back as a data attribute string (as in original)
            hand.data("fan", 'radius: ' + options.radius + '; spacing: ' + options.spacing);

            // Add card images if 'cards' option is provided
            if (options.cards) {
                addCardImages(hand, options.cards);
            }

            cards = hand.find("img.card") as JQuery<HTMLImageElement>;
            if (cards.length === 0) {
                return;
            }
            if (options.width) {
                cards.width(options.width);
            }
            // Pass 'this' (the module object) explicitly as 'self' to fanCards
            fanCards(cards, this, options);
        },

        hand: function ($hand: JQuery<HTMLElement>, cfg?: Partial<CardsOptions>): void {
            // Create a mutable copy of default options
            let options: CardsOptions = { ...this.options };
            let cards: JQuery<HTMLImageElement>;
            // let generator: string | undefined; // Not used in the original logic after assignment
            let width: number;
            let height: number;

            // Extend options with data attributes, then with cfg
            options = $.extend(options, readOptions($hand, 'hand'));
            if (cfg) {
                options = $.extend(options, cfg);
            }
            // Store the effective options back as a data attribute string (as in original)
            $hand.data("hand", 'flow: ' + options.flow + '; spacing: ' + options.spacing); // Added spacing here for consistency

            // Manage CSS classes based on flow and spacing
            $hand.removeClass('hhand fan hhand vhand vhand-compact hhand-compact'); // Remove all relevant classes first
            if (options.flow === 'vertical') {
                if (options.spacing >= 1.0) {
                    $hand.addClass('vhand');
                } else {
                    $hand.addClass('vhand-compact');
                }
            } else { // horizontal flow
                if (options.spacing >= 1.0) {
                    $hand.addClass('hhand');
                } else {
                    $hand.addClass('hhand-compact');
                }
            }

            // console.log(options.cards); // Preserved console log
            if (options.generator === 'random') {
                options.cards = generateSingleHand();
            }

            // console.log(options.cards); // Preserved console log

            // Add card images if 'cards' option is provided
            // Note: Unlike fan(), hand() *always* calls addCardImages if options.cards exists,
            // potentially replacing existing cards.
            if (options.cards) {
                addCardImages($hand, options.cards);
            }


            cards = $hand.find('img.card') as JQuery<HTMLImageElement>;
            if (cards.length === 0) {
                return;
            }
            if (options.width) {
                cards.width(options.width);
            }

            // Get dimensions, providing fallbacks for hidden elements
            const firstCardElement = cards.get(0); // Get the raw DOM element
            width = options.width || (firstCardElement?.clientWidth || 0) || 70; // hack: for a hidden hand
            height = (firstCardElement?.clientHeight || 0) || Math.floor(width * 1.4); // hack: for a hidden hand

            // Apply negative margins for compact layouts
            if (options.flow === 'vertical' && options.spacing < 1.0) {
                cards.slice(1).css('margin-top', -height * (1.0 - options.spacing));
                cards.slice(1).css('margin-left', 0); // Ensure horizontal margin is reset
            } else if (options.flow === 'horizontal' && options.spacing < 1.0) {
                cards.slice(1).css('margin-left', -width * (1.0 - options.spacing));
                cards.slice(1).css('margin-top', 0); // Ensure vertical margin is reset
            } else {
                // Reset margins for non-compact layouts or if switching layout types
                cards.slice(1).css('margin-left', '');
                cards.slice(1).css('margin-top', '');
            }
        },

        cardSetTop: function (card: HTMLImageElement, top: number): void {
            card.style.top = top + "px";
        },

        cardNames: function (cards: string | string[]): string[] {
            let i: number;
            let name: string;
            let names: string[] = [];
            let cardArray: string[];

            if (typeof cards === 'string') {
                // Split string by spaces and filter out empty strings
                cardArray = cards.split(' ').filter(c => c.length > 0);
            } else {
                cardArray = cards;
            }

            // Normalise the card names.
            for (i = 0; i < cardArray.length; ++i) {
                // Ensure the item exists and convert to string before calling toUpperCase
                if (cardArray[i]) {
                    name = cardArray[i].toString().toUpperCase();
                    names.push(name);
                }
            }

            return names;
        },

        // playCard is assigned later, needs initial type compatibility
        playCard: (card: JQuery<HTMLImageElement>): void => {
            // Default implementation will be overwritten, but provide a stub
            console.warn("playCard called before initialization, removing card.");
            module.remove(card); // Call remove by default before assignment
        }
    };

    // The default is to remove the card from the hand.
    // Assign the remove function to playCard after module is defined
    module.playCard = module.remove;

    // Helper function to add card images to a hand element
    function addCardImages(hand: JQuery<HTMLElement>, cards: string | string[] | undefined): void {
        let i: number;
        let src: string;
        if (!cards) {
            return;
        }
        // Normalize card names using the module's method
        const normalizedCards = module.cardNames(cards);

        hand.empty(); // Clear existing cards
        for (i = 0; i < normalizedCards.length; ++i) {
            // Construct the src attribute string
            src = "src='" + module.options.imagesUrl + normalizedCards[i] + '.svg' + "'";
            // Append the image element
            hand.append("<img class='card' " + src + " alt='" + normalizedCards[i] + "'>"); // Added alt attribute
        }
    }

    // Parse the data-name attribute in HTML.
    function readOptions($elem: JQuery<HTMLElement>, name: string): ParsedOptions {
        let v: string | number | string[]; // Value part of the key-value pair
        let i: number, len: number;
        let s: string[]; // Key-value pair split by ':'
        let optionsString: string | undefined;
        let optionsArray: string[];
        let o: ParsedOptions = {}; // Parsed options object

        optionsString = $elem.data(name) as string | undefined; // Get data attribute value
        // Ensure optionsString is a string before processing
        optionsArray = (optionsString || '').replace(/\s/g, '').split(';').filter(opt => opt.length > 0); // Remove whitespace, split by ';', filter empty

        for (i = 0, len = optionsArray.length; i < len; i++) {
            s = optionsArray[i].split(':');
            if (s.length === 2) { // Ensure it's a key:value pair
                const key = s[0];
                const valueString = s[1];

                if (valueString && valueString.includes(',')) {
                    // If value contains comma, treat as array of strings
                    v = valueString.split(',');
                } else {
                    // Attempt to convert to number, otherwise keep as string
                    const num = Number(valueString);
                    v = isNaN(num) ? valueString : num;
                }
                o[key] = v;
            }
        }
        // console.log(o); // Original code logged the split array, not the object. Logging object 'o' instead.
        return o;
    }

    // Helper function to arrange cards in a fan
    function fanCards(cards: JQuery<HTMLImageElement>, self: typeof module, options: CardsOptions): void {
        let n = cards.length;
        if (n === 0) {
            return;
        }

        // Get dimensions, providing fallbacks for hidden elements
        const firstCardElement = cards.get(0); // Get the raw DOM element
        let width = options.width || (firstCardElement?.clientWidth || 0) || 90; // hack: for a hidden hand
        let height = (firstCardElement?.clientHeight || 0) || Math.floor(width * 1.4); // hack: for a hidden hand

        // Box object to store calculated dimensions
        let box: Box = { width: 0, height: 0 };

        // Calculate coordinates for each card
        let coords: CardCoord[] = calculateCoords(n, options.radius, width, height, options.fanDirection, options.spacing, box);

        let hand = cards.first().parent(); // Get the parent container (hand)
        // Set the hand container dimensions based on calculated box size
        hand.width(box.width);
        hand.height(box.height);

        let i = 0;
        coords.forEach(function (coord) {
            let card = cards.get(i++); // Get the raw DOM element
            if (!card) return; // Should not happen, but type guard

            card.style.position = 'absolute'; // Ensure cards can be positioned
            card.style.left = coord.x + "px";
            card.style.top = coord.y + "px";

            // Store original y for mouseout
            const originalY = coord.y;
            card.onmouseover = function () {
                // Use self (which is the module instance) to call cardSetTop
                self.cardSetTop(card, originalY - 10);
                // Bring card to front on hover
                $(card).css('z-index', n + 1);
            };
            card.onmouseout = function () {
                // Use self (which is the module instance) to call cardSetTop
                self.cardSetTop(card, originalY);
                // Reset z-index
                $(card).css('z-index', '');
            };

            let rotationAngle = Math.round(coord.angle);
            // Apply rotation using vendor prefixes (as in original)
            let prefixes = ["Webkit", "Moz", "O", "ms", ""]; // Added empty prefix for standard transform
            prefixes.forEach(function (prefix) {
                const transformProperty = prefix ? prefix + "Transform" : "transform";
                // Use type assertion to access style properties dynamically
                (card.style as any)[transformProperty] = "rotate(" + rotationAngle + "deg)" + " translateZ(0)"; // translateZ(0) to hint hardware acceleration
            });
            // Set initial z-index based on position
            $(card).css('z-index', i);
        });
    }

    // Helper function to calculate card coordinates for the fan layout
    function calculateCoords(numCards: number, arcRadius: number, cardWidth: number, cardHeight: number, direction: 'N' | 'S' | 'E' | 'W', cardSpacing: number, box: Box): CardCoord[] {
        // The separation between the cards, in terms of rotation around the circle's origin
        // Ensure arcRadius is not zero to avoid division by zero
        const effectiveRadius = Math.max(1, arcRadius);
        let anglePerCard = Math.radiansToDegrees(Math.atan(((cardWidth * cardSpacing) / effectiveRadius)));

        // Angle offset based on direction
        let angleOffset = ({ "N": 270, "S": 90, "E": 0, "W": 180 })[direction];

        // Calculate the starting angle for the first card
        let startAngle = angleOffset - 0.5 * anglePerCard * (numCards - 1);

        let coords: CardCoord[] = [];
        let i: number;
        // Initialize bounds for calculating final container size
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;

        // Calculate initial position and angle for each card
        for (i = 0; i < numCards; i++) {
            let degrees = startAngle + anglePerCard * i;
            let radians = Math.degreesToRadians(degrees);

            // Calculate position relative to the fan's center point (before offset)
            // The center of the card should be on the arc
            let x = Math.cos(radians) * effectiveRadius;
            let y = Math.sin(radians) * effectiveRadius;

            // Store coordinates and angle (angle adjusted for CSS rotation)
            coords.push({ x: x, y: y, angle: degrees + 90 });
        }

        // Calculate the bounding box of the *rotated* cards to determine offsets
        let overallMinX = Infinity;
        let overallMinY = Infinity;
        let overallMaxX = -Infinity;
        let overallMaxY = -Infinity;

        coords.forEach((coord, index) => {
            const angle = coord.angle; // CSS rotation angle
            const halfWidth = cardWidth / 2;
            const halfHeight = cardHeight / 2;

            // Calculate corners of the card *after* rotation around its center (0,0 relative to card center)
            const corners = [
                Math.rotatePointInBox(-halfWidth, -halfHeight, angle, cardWidth, cardHeight),
                Math.rotatePointInBox( halfWidth, -halfHeight, angle, cardWidth, cardHeight),
                Math.rotatePointInBox( halfWidth,  halfHeight, angle, cardWidth, cardHeight),
                Math.rotatePointInBox(-halfWidth,  halfHeight, angle, cardWidth, cardHeight)
            ];

            // Translate corners to the card's position in the fan (coord.x, coord.y is the center)
            corners.forEach(corner => {
                const finalX = coord.x + corner[0];
                const finalY = coord.y + corner[1];
                overallMinX = Math.min(overallMinX, finalX);
                overallMinY = Math.min(overallMinY, finalY);
                overallMaxX = Math.max(overallMaxX, finalX);
                overallMaxY = Math.max(overallMaxY, finalY);
            });
        });


        // Calculate the offset needed to position the top-left corner of the bounding box at (0,0)
        let offsetX = -overallMinX;
        let offsetY = -overallMinY;


        // --- Original Offset Logic (commented out, replaced by bounding box calculation) ---
        // This logic seemed complex and potentially incorrect, especially for E/W.
        // The bounding box approach is generally more robust for fitting rotated elements.
        /*
        let rotatedDimensions = Math.getRotatedDimensions(coords[0].angle, cardWidth, cardHeight);
        let offsetX = 0;
        let offsetY = 0;

        if (direction === "N") {
            offsetX = (minX * -1); // minX was calculated based on card centers, not corners
            offsetX += ((rotatedDimensions[0] - cardWidth) / 2);
            offsetY = (minY * -1);
        } else if (direction === "S") {
            offsetX = (minX * -1);
            offsetX += ((rotatedDimensions[0] - cardWidth) / 2);
            offsetY = ((minY + (maxY - minY)) * -1); // This seems overly complex: just -maxY?
        } else if (direction === "W") {
            offsetY = (minY * -1);
            offsetY += ((rotatedDimensions[1] - cardHeight) / 2);
            offsetX = (minX * -1);
            offsetX += (cardHeight - Math.rotatePointInBox(0, 0, 270, cardWidth, cardHeight)[1]); // Complex calculation
        } else if (direction === "E") {
            offsetY = (minY * -1);
            offsetY += ((rotatedDimensions[1] - cardHeight) / 2);
            offsetX = (effectiveRadius) * -1; // Why radius?
            offsetX -= (cardHeight - Math.rotatePointInBox(0, 0, 270, cardWidth, cardHeight)[1]); // Complex calculation
            //offsetX -= ?????;    // HELP! Needs to line up with yellow line!
        }
        */
        // --- End of Original Offset Logic ---


        // Apply the calculated offset to each card's center coordinate and round
        coords.forEach(function (coord) {
            // Adjust position by half card dimensions because x,y were calculated for the center
            coord.x += offsetX - (cardWidth / 2);
            coord.x = Math.round(coord.x);

            coord.y += offsetY - (cardHeight / 2);
            coord.y = Math.round(coord.y);

            coord.angle = Math.round(coord.angle); // Keep angle as calculated
        });

        // Calculate final bounding box dimensions based on the overall min/max of corners
        box.width = Math.round(overallMaxX - overallMinX);
        box.height = Math.round(overallMaxY - overallMinY);

        // --- Original Box Size Calculation (commented out) ---
        // This calculation seemed incorrect as it only considered the last card's top-left corner + dimensions.
        // box.width = coords[numCards - 1].x + cardWidth;
        // box.height = coords[numCards - 1].y + cardHeight;
        // --- End of Original Box Size Calculation ---

        return coords;
    }


    // If loaded directly from a script, the do the jquery shuffle.
    // Use DOMContentLoaded for potentially earlier execution than 'load'
    $(function () { // Equivalent to $(document).ready() / DOMContentLoaded
        // Adjust the cards in a fan, except ones using KO (Knockout.js binding assumed)
        $(".fan:not([data-bind])").each(function () {
            // Pass 'this' (the DOM element) wrapped in jQuery to the module's fan function
            module.fan($(this));
        });

        // Process any data-hand attributes
        $(".hand[data-hand]").each(function () {
            // Pass 'this' (the DOM element) wrapped in jQuery to the module's hand function
            module.hand($(this));
        });

        // Call cards.play, when a card is clicked in an active hand.
        // Use event delegation on existing or future .hand elements
        $(document).on("click", ".hand img.card", function (event) {
            // Pass the clicked card (as a jQuery object) to the module's play function
            // 'this' inside the handler refers to the clicked img.card element
            module.play($(this as HTMLImageElement));
        });
    });

    // Default imagesUrl to a subfolder of the script source.
    if (cardsScript && cardsScript.src) {
        // Get the directory path of the current script
        try {
            const scriptUrl = new URL(cardsScript.src);
            const scriptPath = scriptUrl.pathname;
            const lastSlashIndex = scriptPath.lastIndexOf('/');
            if (lastSlashIndex !== -1) {
                // Construct path relative to script location
                const path = scriptPath.substring(0, lastSlashIndex + 1) + 'cards/';
                // Ensure the path starts from the root if the script path was absolute
                module.options.imagesUrl = new URL(path, scriptUrl.origin).pathname;
                // Or if relative paths are desired (less robust):
                // module.options.imagesUrl = scriptPath.substring(0, lastSlashIndex + 1) + 'cards/';
            }
        } catch (e) {
            console.error("Could not parse cardsScript.src URL:", cardsScript.src, e);
            // Fallback or keep the default 'cards/'
            module.options.imagesUrl = 'cards/';
        }

        // Original simpler logic (might not work correctly with complex base URLs):
        // let path = cardsScript.src.substring(0, cardsScript.src.lastIndexOf('/')) + '/cards/';
        // module.options.imagesUrl = path;
    } else {
        console.warn("Could not determine script path, using default imagesUrl:", module.options.imagesUrl);
    }


    // Just return a value to define the module export.
    // This example returns an object, but the module
    // can return a function as the exported value.
    return module;

// Pass jQuery to the factory function
})($);


// Math Additions - These augment the global Math object.
// Ensure they are defined only once.
if (!Math.degreesToRadians) {
    Math.degreesToRadians = function (degrees: number): number {
        return degrees * (Math.PI / 180);
    };
}

if (!Math.radiansToDegrees) {
    Math.radiansToDegrees = function (radians: number): number {
        return radians * (180 / Math.PI);
    };
}

if (!Math.getRotatedDimensions) {
    /**
     * Calculates the dimensions of a bounding box for a rotated rectangle.
     * @param angle_in_degrees The rotation angle in degrees.
     * @param width The original width of the rectangle.
     * @param height The original height of the rectangle.
     * @returns A tuple [rotatedWidth, rotatedHeight].
     */
    Math.getRotatedDimensions = function (angle_in_degrees: number, width: number, height: number): [number, number] {
        let angle = Math.degreesToRadians(angle_in_degrees), // Convert to radians
            sin   = Math.sin(angle),
            cos   = Math.cos(angle);
        // Calculate coordinates of the 4 corners relative to the rotation origin (0,0)
        let x1 = cos * width, // Top-right corner (relative to top-left)
            y1 = sin * width;
        let x2 = -sin * height, // Bottom-left corner (relative to top-left)
            y2 = cos * height;
        let x3 = cos * width - sin * height, // Bottom-right corner (relative to top-left)
            y3 = sin * width + cos * height;
        // Find the min/max x and y coordinates among the original top-left (0,0) and the other 3 corners
        let minX = Math.min(0, x1, x2, x3),
            maxX = Math.max(0, x1, x2, x3),
            minY = Math.min(0, y1, y2, y3),
            maxY = Math.max(0, y1, y2, y3);

        // The dimensions are the difference between max and min coordinates
        return [ Math.floor((maxX - minX)), Math.floor((maxY - minY)) ];
    };
}

if (!Math.rotatePointInBox) {
    /**
     * Rotates a point (x, y) around the center of a box (width, height) by a given angle.
     * @param x The initial x-coordinate of the point relative to the box's top-left.
     * @param y The initial y-coordinate of the point relative to the box's top-left.
     * @param angle The rotation angle in degrees.
     * @param width The width of the box.
     * @param height The height of the box.
     * @returns A tuple [newX, newY] representing the rotated coordinates relative to the box's top-left.
     */
    Math.rotatePointInBox = function (x: number, y: number, angle: number, width: number, height: number): [number, number] {
        const radAngle = Math.degreesToRadians(angle); // Convert angle to radians

        // Coordinates of the box center
        let centerX = width / 2.0;
        let centerY = height / 2.0;

        // Translate point so the center of the box is the origin
        let dx = x - centerX;
        let dy = y - centerY;

        // Rotate the translated point
        // Using standard 2D rotation formulas:
        // x' = x*cos(a) - y*sin(a)
        // y' = x*sin(a) + y*cos(a)
        let rotatedX = dx * Math.cos(radAngle) - dy * Math.sin(radAngle);
        let rotatedY = dx * Math.sin(radAngle) + dy * Math.cos(radAngle);


        // --- Original calculation using distance and atan2 (commented out for clarity, result is the same) ---
        // let dist = Math.sqrt(dx * dx + dy * dy); // Distance from center
        // let a =  Math.atan2(dy, dx) + radAngle; // Original angle + rotation angle
        // let dx2 = Math.cos(a) * dist; // New x relative to center
        // let dy2 = Math.sin(a) * dist; // New y relative to center
        // --- End of Original Calculation ---


        // Translate the point back to the original coordinate system
        return [ rotatedX + centerX, rotatedY + centerY ];
    };
}

// Export the module instance for use in other TypeScript modules
export default cardsModule;
